#include <iostream>
using namespace std;

//climb stairs
int solve(int N)
{
    vector<int>dp(N,0);
    dp[0] = 1;
    dp[1] = 1;
    for(int i = 2 ; i < N ; i++)
    {
        dp[i] = dp[i-1] + dp[i-2];
    }
    return dp[N-1];
}
//house robber
int rob(vector<int> &nums)
{
    int n = nums.size();
    if(n == 1)
        return nums[0];

    vector<int>dp(n,0);
    
    dp[n-1] = nums[n-1];
    dp[n-2] = max(nums[n-1],nums[n-2]);
    
    for(int i = n-3 ; i>= 0 ; i--)
    {
        dp[i] = max(dp[i+1],nums[i]+dp[i+2]);
    }
    return dp[0];
    
}

//house robber 2

//delete and earn(same as house robber)
int solve(vector<int>nums)
{
    int n = 1e4+1;
    vector<int>val(n,0);
    
    for(int i = 0 ; i < nums.size() ; i++)
    {
        val[nums[i]] += nums[i];
    }
    
    vector<int>dp(n,0);
    dp[1] = nums[0];
    dp[2] = max(nums[0] ,nums[1]);
    
    for(int i = 3 ; i < n ; i++)
    {
        dp[i] = max(val[i] + dp[i-2], dp[i]);
    }
    return max(d[10000],dp[9999]);
}
//painiting fence problem
int solve(int n , int k)
{
    int diff = k;//signifining no. of ways to color 1 fense
    int same = 0;//no. of ways to color last two fanse with same color. Not possible if we have only one fense
    int total = same + diff ;//total no. of ways to color 1 fense
    
    for(int i = 2 ; i<= n ; i++)
    {
        same = diff * (1);
        diff = total * (k-1);
        total = same + diff;    
    }
    return total;
    
}

//house robbery 3 

class housepair
{
  public:
    int withRobbery
    int withoutRobbery;
    
    housepair()
    {
        withoutRobbery = 0;
        withRobbery = 0;
    }
};

housepair solve(TreeNode* root)
{
    if(root == NULL)
    {
        housepair p = new housepair();
        return p;
    }
    
    housepair left = solve(root->left);
    housepair right = solve(root->right);
    
    housepair myans = new housepair();
    myans.withRobbery = root->val + left.withoutRobbery + right.withoutRobbery;
    myans.withoutRobbery = max(left.withoutRobbery,left.withRobbery) + max(right.withoutRobbery,right.withRobbery);
    return myans;
}

int rob(TreeNode *root)
{
    housepair ans = solve(root);
    return max(ans.withRobbery,ans.withoutRobbery);
}

//max product subarray

int solve(vector<int> &arr)
{
    int overall_max = 0;
    int max_ending = 1;
    int min_ending = 1;
    
    int flag = 0;
    
    for(int i = 0 ; i < n ; i++)
    {
        if(arr[i] > 0)
        {
            max_ending *=arr[i];
            min_ending = min(min_ending * arr[i],1);
            flag = 1;
        }
        
        else if(arr[i] == 0)
        {
            max_ending = 1;
            min_ending = 1;
        }
        
        else{
            int temp = max_ending;
            max_ending = max(min_ending*arr[i],1);
            min_ending = temp * arr[i];
        }
        
        if(overall_max < max_ending)
            overall_max = max_ending;
    }
    
    if(flag == 0 && overall_max == 0)
        return 0;
    return overall_max;
}

//longest incresing subsequence

int LIS(vector<int>arr)
{
    int n = arr.size();
    vector<int>dp(n,1);
    
    for(int i = 1 ; i < n ; i++)
    {
        for(int j = 0 ; j <= i ; j++)
        {
            if(arr[i] > arr[j])
                dp[i] = max(dp[j]+1,dp[i]);
        }
    }
    return dp[n-1];
}

//LIS in nlogn time complexity(IMP)
 int lengthOfLIS(vector<int>& nums) {
        vector<int> sub;
        for (int x : nums) {
            if (sub.empty() || sub[sub.size() - 1] < x) {
                sub.push_back(x);
            } else {
                auto it = lower_bound(sub.begin(), sub.end(), x); // Find the index of the smallest number >= x
                *it = x; // Replace that number with x
            }
        }
        return sub.size();
    }

//longest common subsequence
int solve(string a , string b , int i , int j , vector<vector<int>>&dp)
{
    if(i ==0 || j ==0 )
    {
        return 0;
    }
    
    if(dp[i][j] != -1)
        return dp[i][j];
        
    if(a[i-1] == b[j-1])
        return dp[i][j] =1 +solve(a,b,i-1,j-1);
    else
        return dp[i][j] = max(solve(a,b,i,j-1) , solve(a,b,i-1,j));
}
int LCS(string a , string b)
{
    int n = a.size();
    int m = b.size();
    
    vector<vector<int>> dp(n+1 , vector<int>(m+1,-1));
    
    return solve(a,b,n,m,dp);
    
}
//lcs iteratively

int lcs (string a , string b)
{
    int n = a.size();
    int m = b.size();
    vector<vector<int>>dp(n+1,vector<int>)
    for(int i = 1 ; i <= n ; i++)
    {
        for(int j = 1 ; j <= m ;j++)
        {
            if(a[i-1] == b[j-1])
                dp[i][j] = dp[i-1][j-1] + 1;
            else
                dp[i][j] = max(dp[i-1][j],dp[i][j-1]);
        }
    }
    return dp[n][m];
}

// 0-1 kanpsack

int kanpsack(vector<int> val , vector<int> wt , int capacity)
{
    int n = val.size()
    vector<vector<int>>dp(n+1,vector<int>(capacity+1 , 0))
    
    for(int i = 1 ; i <= n ; i++)
    {
        for(int j = 1 ; j <= m ; j++)
        {
            if(wt[i-1] <= j)
            {
                dp[i][j] = max(dp[i-1][j] , val[i-1]+dp[i-1][j - wt[i]])
            }
            else
                dp[i][j] = dp[i-1][j];
        }
    }
    return dp[n][m];
}

//edit distance

int solve(string a , string b)
{
    int n = a.size();
    int m = b.size();
    
    vector<vector<int>> dp(n,vector<int>(m,0));
    
    for(int i = 0 ; i <= n ; i++)
    {
        for(int j = 0 ; j <= m ; j++)
        {
            if(i == 0 && j == 0)
                dp[i][j] = 0;
            else if(i == 0)
                dp[i][j] = i;
            else if(j == 0)
                dp[i][j] = j;
            
            else if(a[i-1] == b[j-1])
                dp[i][j] = dp[i-1][j-1];
                
            else
            {
                dp[i][j] = 1+min(dp[i-1][j] , d[i][j-1] , dp[i-1][j-1]);
                
                
            }
        }
        return dp[n][m];
    }
}

//Maximum Sum Increasing Subsequence

int solve(vector<int> &arr)
{
    int n = arr.size();
    vector<int>dp(n,0);
    dp[0] = arr[0];
    for(int  i = 1 ; i < n ; i++)
    {
        for(int j = 0 ; j < i ; j++)
        {
            dp[i] = arr[i];
            if(arr[j] < arr[i])
            {
                dp[i] = max(dp[i] , dp[j] + arr[i]);
            }
        }
    }
    return dp[n-1];
}

//Maximum path sum in matrix
int findMaxPath(vector<int> &mat)
{
    int n = mat.size();
    int m = mat[0].size();
    
    for(int i = 1 ; i < n ; i++)
    {
        for(int j = 0 ; j < m ;j++)
        {
            if( j > 0 && j < m-1)
            {
                mat[i][j] += max(mat[i-1][j],max(mat[i-1][j-1] , mat[i-1][j+1]));
            }
            else if( j == 0)
            {
                mat[i][j] += max(mat[i-1][j],mat[i-1][j+1]);
            }
            else if( j == m-1)
            {
                mat[i][j] += max(mat[i-1][j],mat[i-1][j+1]);
            }
        }
        
    }
    int res = 0;
    for (int j = 0; j < M; j++)
        res = max(mat[N-1][j], res);
    return res;
}

//coin change
int solve(vector<int> &coin , int N)
{
    int n = coin.size();
    vector<vector<int>>dp(n+1,vector<int>(N+1,0));
    
    for(int i = 1 ; i <= n ; i++)
    {
        for(int j = 1 ; j <=N ; j++)
        {
            if(coin[i] <= j)
            {
                dp[i][j] = max(dp[i][j] ,dp[i][j-coin[i]] + dp[i-1][j]) ;
            }
        }
    }
    return dp[n][N];
}
//Subset Sum Problem

int solve(vector<int> set,int sum)
{
    int n = set.size();
    
    vector<vector<bool>> dp(n+1,vector<bool>(sum+1,false));
    
    for(int i = 0 ; i < n ; i++)
    {
        dp[i][0] = true;
    }
    
    for(int i = 1 ; i <= n ; i++)
    {
        for(int j =1 ; j<= sum ;j++)
        {
            dp[i][j] = dp[i-1][j];
            if(set[i-1] <= j)
            {
                dp[i][j] = dp[i-1][j-set[i-1]] || dp[i-1][j];
            }
        }
    }
    return dp[n][sum];
}

//
